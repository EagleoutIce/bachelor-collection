%% iris icon network generator package
%% Florian Sihler, 2021-03-14

\ProvidesPackage{iris-ico-net}[2021/03/14 v1.0 iris icon network generator package]

\RequirePackage{tikz,etoolbox}

% TODO: color Palettes
% TODO: extend with kprim selection etc
% TODO: cycle colors
\colorlet{iinet@block}{green}
\colorlet{iinet@connection}{purple}

\newcounter{iinet@block@count}

% The goal is to create small icons of given sizes
% which all present a random but simple iris icon
% pt will serve as the basic unit

\def\iinet@newlength#1=#2;{% legacy :C
\expandafter\newlength\csname iinet@#1\endcsname
\expandafter\newlength\csname iinet@default@#1\endcsname
\expandafter\csname iinet@default@#1\endcsname=#2}
\def\iinet@newreg#1=#2;{\expandafter\def\csname iinet@default@#1\endcsname{#2}}

\iinet@newreg padding@x=1;
\iinet@newreg padding@y=1;


% TODO: i use inset as buffer for not working checks
\iinet@newreg inset@x=2;
\iinet@newreg inset@y=2;


% TODO make this 42 again :D
\iinet@newreg width=30;
\iinet@newreg height=30;

\iinet@newreg block@min@width=7;
\iinet@newreg block@max@width=13;
\iinet@newreg block@min@height=6;
\iinet@newreg block@max@height=8;

\newif\if@iinet@flag@a@
\newif\if@iinet@flag@typeset@block@

\newif\if@iinet@drawframe
\newif\if@iinet@drawgrid
\tikzset{%
    iinet@frame/.style={draw,rounded corners=2pt},
    iinet@grid/.style={gray,ultra thin,step=1},
    iinet@block/.style={fill=#1,draw=#1,rounded corners=.25pt}%
}

\pgfkeys{%
    /iinet@keys/.is family, /iinet@keys,
    width/.store in=\iinet@width, height/.store in=\iinet@height,
    padding/.code={\def\iinet@padding@x{#1}\def\iinet@padding@y{#1}},
    padding x/.store in=\iinet@padding@x,
    padding y/.store in=\iinet@padding@y,
    inset/.code={\def\iinet@inset@x{#1}\def\iinet@inset@y{#1}},
    inset x/.store in=\iinet@inset@x,
    inset y/.store in=\iinet@inset@y,
    block min width/.store in=\iinet@block@min@width,
    block max width/.store in=\iinet@block@max@width,
    block min height/.store in=\iinet@block@min@height,
    block max height/.store in=\iinet@block@max@height,
    frame/.is if=@iinet@drawframe,
    grid/.is if=@iinet@drawgrid,
    defaults/.style={%
        width=\iinet@default@width, height=\iinet@default@height,
        padding x=\iinet@default@padding@x, padding y=\iinet@default@padding@y,
        inset x=\iinet@default@inset@x, inset y=\iinet@default@inset@y,
        block min width=\iinet@default@block@min@width,
        block max width=\iinet@default@block@max@width,
        block min height=\iinet@default@block@min@height,
        block max height=\iinet@default@block@max@height,
    }%
}

% location (upper-left) | color | width | height
\def\iinet@draw@single@@block#1#2#3#4{%
    \path[iinet@block=#2] (#1)++(\iinet@inset@x,\iinet@inset@y) rectangle ++(#3-\iinet@inset@x,#4-\iinet@inset@y);
}

\def\iinet@getblock#1{\csname iinet@block@\arabic{iinet@block@count}@#1\endcsname}

\def\iinet@setblock#1#2{%
\expandafter\edef\csname iinet@block@\arabic{iinet@block@count}@#1\endcsname{#2}%
}

\def\iinet@setblockrand#1#2#3{\pgfmathrandominteger{\@iinet@tmp}{#2}{#3}\setblock{#1}{\@iinet@tmp}}


%%% How (TODO: rasterize: TODO: maximum number? TODO: padding [save #pt bigger blocks?])
% NOTE: changed usage... not min; inefficient approach at first ^^
% 1) calculate differences between min and max for both dimens: block@dif@{x,y}
% 2) hold a list for all y with [height-block@min@height] elements:
%       list for all x with [width-block@min@width] elements
%    => Listname is 'matrix'
% 3) update present squares:
%   foreach y:
%     max@[y]@x = min(longest consecutive x in cur:y, block@dif@x)
%     if max@[y]@x<block@min@x: [[Throw; y]]
%   max@y = min(longest consecutive y, block@dif@y)
%   if max@y<block@min@y: [[ERROR]]
%
% update present squares()
%
% ------------------------ on block:
% 4) rand@h = rand(block@y@min, max@y)
% 5) pick random y in list.
%   if any in [y..y+rand@h] not in ylist: [[mod-cycle until it fits]] // has to for y
%   (side:) calculate max@x width possible in [y..y+rand@h] // has to for x
% 6) rand@w = rand(block@x@min, max@x)
% pick random x fitting that width
%
% place block (x, y, rand@w, rand@h)
% kill fields1

\newcounter{iinet@x}
\newcounter{iinet@y}
\newcounter{iinet@a}
\newcounter{iinet@b}
\newcounter{iinet@c}

\def\iinet@calcdiffs{
    \edef\iinet@block@dif@x
        {\the\numexpr\iinet@block@max@width-\iinet@block@min@width\relax}
    \edef\iinet@block@dif@y
        {\the\numexpr\iinet@block@max@height-\iinet@block@min@height\relax}
    \edef\iinet@matrix@x
        {\the\numexpr\iinet@width\relax}
    \edef\iinet@matrix@y
        {\the\numexpr\iinet@height\relax}
}

\def\iinet@element{}

%%% The Lists (why not rndlist? Manipulating them can be quite tedious)
\def\iinet@setup@matrix{
    \iinet@m@for@y{% for each y
        \expandafter\let\csname iinet@m@\arabic{iinet@y}\endcsname\iinet@element
        \iinet@m@for@x{% for each x
            \expandafter\let\csname iinet@m@\arabic{iinet@y}@%
                        \arabic{iinet@x}\endcsname\iinet@element
        }
    }
    \iinet@update@present@squares
}

% (x, y)
\def\iinet@m@get(#1,#2){\@nameuse{iinet@m@#2@#1}}
% (x, y) but with counters
\def\iinet@m@cget(#1,#2){\iinet@m@get(\arabic{#1},\arabic{#2})}


\long\def\iinet@if@m@free(#1,#2)#3#4{\ifcsname iinet@m@#2@#1\endcsname#3\else#4\fi}
\def\iinet@if@m@cfree(#1,#2){\iinet@if@m@free(\arabic{#1},\arabic{#2})}


\def\iinet@m@block(#1,#2){%
    \expandafter\expandafter\expandafter\expandafter\expandafter\expandafter\expandafter%
    \undef\iinet@m@get(#1,#2)}
\def\iinet@m@cblock(#1,#2){\iinet@m@block(\arabic{#1},\arabic{#2})}

\long\def\iinet@m@for@y#1{%
\setcounter{iinet@y}{0}%
\@whilenum\value{iinet@y}<\iinet@matrix@y\do{%
    \setcounter{iinet@x}{0}#1\stepcounter{iinet@y}%
}}

\long\def\iinet@m@for@x#1{%
\@whilenum\value{iinet@x}<\iinet@matrix@x\do{% for each x
    #1\stepcounter{iinet@x}%
}}


\def\iinet@m@max@of@y#1{\ifcsname iinet@max@#1@x\endcsname\@nameuse{iinet@max@#1@x}\else-1\fi}
\def\iinet@get@consecutive@x@{\ifnum\value{iinet@a}>\@iinet@con@x\relax\edef\@iinet@con@x{\arabic{iinet@a}}\fi\setcounter{iinet@a}{0}}

\def\iinet@get@consecutive@x#1{%
    % do not run if already known 0
    \ifnum\iinet@m@max@of@y{\arabic{iinet@y}}=0\relax\else
    \setcounter{iinet@a}{0}% current
    \def\@iinet@con@x{0}% maximum
    \setcounter{iinet@x}{#1}% start x
    \iinet@m@for@x{%
        \iinet@if@m@cfree(iinet@x,iinet@y)%
            {\stepcounter{iinet@a}}% free
            {\iinet@get@consecutive@x@}%
    }\iinet@get@consecutive@x@\fi
}

\def\iinet@get@consecutive@y@{\ifnum\value{iinet@a}>\@iinet@con@y\relax\edef\@iinet@con@y{\arabic{iinet@a}}\fi\setcounter{iinet@a}{0}}
\def\iinet@get@consecutive@y{%
    \setcounter{iinet@a}{0}% current
    \setcounter{iinet@b}{0}% total added
    \def\@iinet@con@y{0}% maximum
    \def\iinet@m@ylist{}%
    \iinet@m@for@y{%
        \ifnum\iinet@m@max@of@y{\arabic{iinet@y}}=0\relax
            \iinet@get@consecutive@y@
        \else
            \stepcounter{iinet@a}\stepcounter{iinet@b}%
            \listeadd\iinet@m@ylist{\arabic{iinet@y}}%
        \fi
    }\iinet@get@consecutive@y@
}

\def\iinet@update@present@squares{%
    % TODO: set error flag (if?) in case of insufficient dimensions
    \iinet@m@for@y{%
        \iinet@get@consecutive@x{0}
        \expandafter\edef\csname iinet@max@\arabic{iinet@y}@x\endcsname{\@iinet@con@x}%
    }
    \iinet@get@consecutive@y
    \expandafter\edef\csname iinet@max@y\endcsname{\@iinet@con@y}%
    \edef\iinet@m@ylist@total{\arabic{iinet@b}}%
}

\def\iinet@debug@line{====================================}
\def\iinet@debug@show@matrix{%
    \typeout{\iinet@debug@line}%
    \typeout{[Constructed \iinet@matrix@x x\iinet@matrix@y; \@nameuse{iinet@max@y} :: (\iinet@m@ylist@total) \iinet@m@ylist]}
    \iinet@m@for@y{% for each y
        \def\iinet@linebuf{}% clear
        \iinet@m@for@x{% for each x
            \iinet@if@m@cfree(iinet@x,iinet@y)%
                {\g@addto@macro\iinet@linebuf{_}}% free
                {\g@addto@macro\iinet@linebuf{O}}% occupied
        }
        \typeout{\iinet@linebuf\space[\arabic{iinet@y}, \iinet@m@max@of@y{\arabic{iinet@y}}]}
    }
    \typeout{\iinet@debug@line}
}


\def\iinet@block@randxy@picky@first{%
    \pgfmathrandominteger{\iinet@rand@y}{0}{\iinet@m@ylist@total-\get{h}-1}
    \setcounter{iinet@a}{0}% current
    \def\iinet@selected@y{-1}%
    \def\do##1{%
        \ifnum\value{iinet@a}=\iinet@rand@y\relax
            \edef\iinet@selected@y{##1}%
        \fi
        \stepcounter{iinet@a}%
    }
    \dolistloop{\iinet@m@ylist}%
}

% start | height
\def\iinet@block@randxy@picky@testfit#1#2{%
    % \iinet@m@max@of@y
    \setcounter{iinet@y}{#1}%
    \@iinet@flag@a@true
    \edef\@iinet@y{\the\numexpr#1+#2+1\relax}% +1 as y not <=
    \@whilenum\value{iinet@y}<\@iinet@y\do{%
        \edef\@iinet@tmp{\iinet@m@max@of@y{\arabic{iinet@y}}}%
        \ifnum\@iinet@tmp<1\relax % 0 or invalid
            \@iinet@flag@a@false
        \fi
        \stepcounter{iinet@y}
    }
}

\def\iinet@block@randxy@picky{%
    % ylist: \iinet@m@ylist (\iinet@m@ylist@total)
    % cycle up to: as the list is sorted ascending,
    % there have to be at least 'h' remaining
    \iinet@block@randxy@picky@first
    \setcounter{iinet@a}{\iinet@selected@y}%
    \ifnum\iinet@selected@y<0\relax
        \PackageWarning{iris-ico-net}{first y pick selected '\iinet@selected@y' which is registered as a warning. Block will be omitted}
        \@iinet@flag@typeset@block@false
    \fi
    \iinet@block@randxy@picky@testfit{\arabic{iinet@a}}{\get{h}}
    \if@iinet@flag@a@\else
        % if this is set iinet@a does not suffice
        % so we cycle until it fits or iinet@a=\iinet@selected@y
        \typeout{Original y-selection (\iinet@selected@y) failed, reshift}
        \setcounter{iinet@b}{0}
        \@whilenum\value{iinet@b}<\iinet@m@ylist@total\do{%
            \pgfmathparse{int(mod(\arabic{iinet@a}+1,\iinet@m@ylist@total))}% mod shift 1
            \setcounter{iinet@a}{\pgfmathresult}
            \iinet@block@randxy@picky@testfit{\arabic{iinet@a}}{\get{h}}% free
            \if@iinet@flag@a@ % can be placed on this height
                \setcounter{iinet@b}{\iinet@m@ylist@total}% 'break'
            \fi
            \stepcounter{iinet@b}
        }
    \fi
    \setblock{y}{\arabic{iinet@a}}%
}

\def\iinet@get@topline@x@{%
    \ifnum\value{iinet@a}<\value{iinet@b}\else
        \listeadd\@iinet@topline@x{\@iinet@curx:\arabic{iinet@a}}%
        \stepcounter{iinet@c}%
        \edef\@iinet@curx{\arabic{iinet@x}}
    \fi
    \setcounter{iinet@a}{0}%#
}

\def\iinet@split@listelem#1:#2;{\edef\iinet@cur@xidx{#1}\edef\iinet@cur@xlen{#2}}

\def\iinet@block@randxy@pickxw@topline{%
    \def\@iinet@topline@x{}
    \ifnum\iinet@m@max@of@y{\arabic{iinet@y}}=0\else
    \setcounter{iinet@a}{0}% current
    \setcounter{iinet@x}{0}%
    \setcounter{iinet@c}{0}% total
    \def\@iinet@curx{0}
    \iinet@m@for@x{%
        \iinet@if@m@cfree(iinet@x,iinet@y)%
            {\stepcounter{iinet@a}}% free
            {\iinet@get@topline@x@}%
    }\iinet@get@topline@x@\fi
    % select random element and split '@'
    \setcounter{iinet@a}{0}% current
    \def\iinet@selected@x{}%
    \pgfmathrandominteger{\iinet@desired@idx}{0}{\value{iinet@c}-1}
    \def\do##1{%
        \ifnum\value{iinet@a}=\iinet@desired@idx\relax
            \edef\iinet@selected@x{##1}%
        \fi
        \stepcounter{iinet@a}%
    }
    \dolistloop{\@iinet@topline@x}%
    \ifx\iinet@selected@x\@empty % if does not catch => save
        \@iinet@flag@typeset@block@false
    \else
        \expandafter\iinet@split@listelem\iinet@selected@x;
    \fi
    % \typeout{Possible for top: \@iinet@topline@x\space=> \iinet@cur@xidx\space and \iinet@cur@xlen}
}

\def\iinet@get@xrange@x@{%
    \ifnum\value{iinet@a}>\@iinet@sub@xlen\relax
        \edef\@iinet@sub@xlen{\arabic{iinet@a}}%
        \edef\@iinet@sub@xidx{\@iinet@sub@lastidx}%
    \fi
    \setcounter{iinet@a}{0}%
    \edef\@iinet@sub@lastidx{\arabic{iinet@x}}
}


\def\iinet@block@randxy@pickxw@xrange{%
    \setcounter{iinet@x}{\iinet@cur@xidx}% current
    \setcounter{iinet@a}{0}%
    \def\@iinet@sub@lastidx{0}%
    \def\@iinet@sub@xidx{0}%
    \def\@iinet@sub@xlen{-1}%
    \@whilenum\value{iinet@x}<\numexpr\iinet@cur@xidx+\iinet@cur@xlen+1\relax\do{
        \iinet@if@m@cfree(iinet@x,iinet@y)%
            {\stepcounter{iinet@a}}% free
            {\iinet@get@xrange@x@}
        \stepcounter{iinet@x}
    }\iinet@get@xrange@x@

    % intersect [sub:xidx..xidx+xlen] and [cur:xidx..xidx+xlen]
    \edef\iinet@cur@xidx@old{\iinet@cur@xidx}
    \ifnum\@iinet@sub@xidx>\iinet@cur@xidx\relax% low
        \edef\iinet@cur@xidx{\@iinet@sub@xidx}
    \fi
    \ifnum\numexpr\@iinet@sub@xidx+\@iinet@sub@xlen\relax<\numexpr\iinet@cur@xidx+\iinet@cur@xlen\relax% len
        \pgfmathsetmacro\iinet@cur@xlen{int(\@iinet@sub@xidx+\@iinet@sub@xlen-\iinet@cur@xidx)}
    \fi
}


\def\iinet@block@randxy@pickxw{%
    % find largest rectangle on y
    % trying from block@min@width up to max@[y]@x
    \setblockrand{w}{\iinet@block@min@width}{min(\iinet@block@max@width,\iinet@m@max@of@y{\get{y}})}%
    \setcounter{iinet@b}{\iinet@block@min@width}%
    \def\iinet@effective@w{0}
    \def\iinet@effective@x{0}
    \@whilenum\value{iinet@b}<\numexpr\get{w}+1\relax\do{%
        \setcounter{iinet@y}{\get{y}}%
        % find start in topline => \iinet@cur@xidx & \iinet@cur@xlen
        \iinet@block@randxy@pickxw@topline
        \stepcounter{iinet@y}
        \if@iinet@flag@typeset@block@
        \@whilenum\value{iinet@y}<\numexpr\get{y}+\get{h}\relax\do{% TODO: maybe +1?
            % search for the largest x-slot in 'xidx..xidx+xlen'
            % if found, it will narrow it down
            \iinet@block@randxy@pickxw@xrange
            \stepcounter{iinet@y}
        }
        \typeout{In run for \arabic{iinet@b}: [\iinet@cur@xidx..+\iinet@cur@xlen]}
        \ifnum\iinet@cur@xlen<\iinet@effective@w\else
            \ifnum\arabic{iinet@b}<\iinet@cur@xlen
            \ifnum\iinet@cur@xidx<0\else
            \edef\iinet@effective@w{\iinet@cur@xlen}
            \edef\iinet@effective@x{\iinet@cur@xidx}
            \edef\iinet@effective@b{\arabic{iinet@b}}
            \typeout{  Updated: [\iinet@effective@x..+\iinet@effective@w]}
        \fi\fi\fi
        \fi
        \stepcounter{iinet@b}
    }
    %\ifnum\value{iinet@x}<\iinet@block@min@width\relax
    %    \@iinet@flag@typeset@block@false % too small to draw
    %\else
    \if@iinet@flag@typeset@block@
        \ifnum\iinet@effective@w<\iinet@block@min@width\relax
            \@iinet@flag@typeset@block@false
        \else
            \pgfmathparse{min(\iinet@effective@w,\get{w},\iinet@effective@b)}
            \setblock{w}{\pgfmathresult}
            \setblockrand{x}{\iinet@effective@x}{\iinet@effective@x+\iinet@effective@w-\get{w}}
        \fi
    \fi
    %\fi
}

% TODO: if fails for current h, try with one h less
\def\iinet@block@randxy{
    \setblockrand{h}{\iinet@block@min@height}{min(\iinet@block@max@height,\iinet@max@y)}% 4)
    \iinet@block@randxy@picky% 5)
    \iinet@block@randxy@pickxw% 6)
}


\def\iinet@single@block@block{
  % block y
  \setcounter{iinet@y}{0}
  \@whilenum\value{iinet@y}<\get{h}\do{%
    \setcounter{iinet@x}{0}%
    \@whilenum\value{iinet@x}<\get{w}\do{%
        \iinet@m@block(%
            \the\numexpr\arabic{iinet@x}+\get{x}\relax,%
            \the\numexpr\arabic{iinet@y}+\get{y}\relax)%
        \stepcounter{iinet@x}% Block!
    }
    \stepcounter{iinet@y}%
  }
  \iinet@update@present@squares
}

% 4)+
\def\iinet@draw@single@block{
  \@iinet@flag@typeset@block@true
  \stepcounter{iinet@block@count}
  % \set and allocate dimens
  % TODO color
  \pgfmathrandominteger{\gradient}{5}{99}
  \setblock{c}{iinet@block!\gradient}
  \iinet@block@randxy
  \if@iinet@flag@typeset@block@
    \typeout{Block[\get{c}](\get{x},\get{y},\get{w},\get{h})}
    \iinet@draw@single@@block{\get{x},\get{y}}{\get{c}}{\get{w}}{\get{h}}
    \iinet@single@block@block
  \fi
}

\def\iinet@init#1{%
    \pgfkeys{/iinet@keys,defaults,#1}%
    \setcounter{iinet@block@count}{0}%
}

\newcommand*\IrisIcoNet[1][]{%
    \iinet@init{#1}%
    \begin{tikzpicture}[x=1pt,y=1pt]
        \let\get\iinet@getblock
        \let\setblock\iinet@setblock
        \let\setblockrand\iinet@setblockrand
        \iinet@calcdiffs% 1)
        \iinet@setup@matrix% 2)
        \if@iinet@drawgrid\draw[iinet@grid] (-\iinet@padding@x,-\iinet@padding@y) grid (\iinet@width+\iinet@padding@x,\iinet@height+\iinet@padding@y);\fi
        \path[use as bounding box,\if@iinet@drawframe iinet@frame\fi]
            (-\iinet@padding@x,-\iinet@padding@y) rectangle (\iinet@width+\iinet@padding@x,\iinet@height+\iinet@padding@y);

        \iinet@draw@single@block
        \iinet@draw@single@block
        \iinet@draw@single@block
        \iinet@draw@single@block
        \iinet@draw@single@block
        \iinet@draw@single@block
        \iinet@draw@single@block
        \iinet@draw@single@block
        \iinet@draw@single@block
        \iinet@draw@single@block
        \iinet@draw@single@block
        \iinet@draw@single@block
        \iinet@draw@single@block
        \iinet@draw@single@block
        \iinet@draw@single@block
        \iinet@draw@single@block
        \iinet@debug@show@matrix% Debug :)
    \end{tikzpicture}%
}


\endinput